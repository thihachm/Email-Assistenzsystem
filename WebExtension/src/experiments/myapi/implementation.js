"use strict";

/**
 * 
 * The class skeleton is partly autogenerated by 
 * Thunderbird Experimental Api Generator.
 * @see https://developer.thunderbird.net/add-ons/mailextensions/experiments#building-the-structure
 * @see https://darktrojan.github.io/generator/generator.html
 *
 */
(function (exports) {
  const { ExtensionCommon } = ChromeUtils.import(
    "resource://gre/modules/ExtensionCommon.jsm"
  );
  const { Services } = ChromeUtils.import(
    "resource://gre/modules/Services.jsm"
  );
  const { XPCOMUtils } = ChromeUtils.import(
    "resource://gre/modules/XPCOMUtils.jsm"
  );
  XPCOMUtils.defineLazyGlobalGetters(exports, ["IOUtils"]);
  class myapi extends ExtensionCommon.ExtensionAPI {
    getAPI(context) {
      return {
        myapi: {
          /**
           * 
           * Return false if the filename is not settings or db since
           * those are the only two files that needs to be written.
           * Otherwise it attempts to write the data into the files.
           * In case that task is succesful the function returns true
           * otherwise the given error from the IOUtils.writeJSON function.
           * 
           * @param {Object} outputJSONObject
           * @param {String} filename
           * @see https://firefox-source-docs.mozilla.org/dom/ioutils_migration.html?highlight=ioutils
           * @returns {Boolean | Object}
           */
          writeJson: async function (outputJSONObject, filename) {
            try {
              if (filename !== "settings" || filename !== "db") {
                return false;
              }
              // build the filepath from the extension
              // location and the config folder
              let filePath =
                context.extension.rootURI.filePath +
                "config/" +
                filename +
                ".json";
              // since "context.extension.rootURI.filePath" returns a unix path
              // delete the first character ("/")
              filePath = filePath.substring(1);
              // replace all "/" with windows conform path seperator ("\\")
              filePath = filePath.replaceAll("/", "\\");

              // let profileDir = FileUtils.getDir("ProfD", []);
              // console.log("Profilverzeichnis:", profileDir);

              await IOUtils.writeJSON(filePath, outputJSONObject);
              return true;
            } catch (error) {
              return error;
            }
          },
        },
      };
    }
    onShutdown(isAppShutdown) {
      // This function is called if the extension is disabled or removed, or Thunderbird closes.
      // We usually do not have to do any cleanup, if Thunderbird is shutting down entirely
      if (isAppShutdown) {
        return;
      }

      // Unload the JSM we imported above. This will cause Thunderbird to forget about the JSM, and
      // load it afresh next time `import` is called. (If you don't call `unload`, Thunderbird will
      // remember this version of the module and continue to use it, even if your extension receives
      // an update.) You should *always* unload JSMs provided by your extension.
      // Cu.unload(extension.rootURI.resolve("modules/myModule.jsm"));

      // Thunderbird might still cache some of your JavaScript files and even if JSMs have been unloaded,
      // the last used version could be reused on next load, ignoring any changes. Get around this issue
      // by invalidating the caches (this is identical to restarting TB with the -purgecaches parameter):
      Services.obs.notifyObservers(null, "startupcache-invalidate", null);
    }
  }

  // Export the api by assigning in to the exports parameter of the anonymous closure
  // function, which is the global this.
  exports.myapi = myapi;
})(this);
