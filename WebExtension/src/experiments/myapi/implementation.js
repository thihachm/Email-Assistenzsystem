/* eslint-disable object-shorthand */

"use strict";

// Using a closure to not leak anything but the API to the outside world.
(function (exports) {

  // Get various parts of the WebExtension framework that we need.
  var { ExtensionCommon } = ChromeUtils.import("resource://gre/modules/ExtensionCommon.jsm");

  // You probably already know what this does.
  var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");

  var { XPCOMUtils } = ChromeUtils.import("resource://gre/modules/XPCOMUtils.jsm");
  XPCOMUtils.defineLazyGlobalGetters(exports, ["IOUtils"]);

  /**
   * ChromeUtils.import() works in experiments for core resource urls as it did
   * in legacy add-ons. However, chrome:// urls that point to add-on resources no
   * longer work, as the "chrome.manifest" file is no longer supported, which
   * defined the root path for each add-on. Instead, ChromeUtils.import() needs
   * a url generated by 
   * 
   * let url = context.extension.rootURI.resolve("path/to/file.jsm")
   *
   * Instead of taking the extension object from the context, you may generate
   * the extension object from a given add-on ID as shown in the example below.
   * This allows to import a JSM without context, for example inside another JSM.
   */

  // This is the important part. It implements the functions and events defined in
  // the schema.json. The name must match what you've been using so far, "myapi" in
  // this case.
  class myapi extends ExtensionCommon.ExtensionAPI {
    getAPI(context) {
      return {
        myapi: {
          readDB: async function (filenpath) {
            let Scope = ChromeUtils.import(
              "resource://gre/modules/osfile/osfile_shared_allthreads.jsm"
            );
            let sep = "/"
            if (Scope.OS.Constants.Win) {
              console.log("win");
              sep = "\\"
            } else {
              console.log("unix");
              sep = "/"
            }

            let folderpath = filenpath + sep + "ERS_Extension"
            if (!await IOUtils.exists(folderpath)) {
              await IOUtils.makeDirectory(folderpath);
            }
            let file = folderpath + sep + "db.json";
            if (await IOUtils.exists(file)) {
              return await IOUtils.readJSON(file);;
            }
            return false
          },
          writeEvent: async function (filename, event, pattern, id) {
            let Scope = ChromeUtils.import(
              "resource://gre/modules/osfile/osfile_shared_allthreads.jsm"
            );
            let sep = "/"
            if (Scope.OS.Constants.Win) {
              console.log("win");
              sep = "\\"
            } else {
              console.log("unix");
              sep = "/"
            }

            let folderpath = filename + sep + "ERS_Extension" + sep + "events"
            if (!await IOUtils.exists(folderpath)) {
              await IOUtils.makeDirectory(folderpath);
            }
            let file = folderpath + sep + "event_" + pattern + "_mail-" + id + ".json";
            return await IOUtils.writeJSON(file, event);
          },
          // https://firefox-source-docs.mozilla.org/dom/ioutils_migration.html?highlight=ioutils
          writeJson: async function (filename, text) {
            let Scope = ChromeUtils.import("resource://gre/modules/osfile/osfile_shared_allthreads.jsm");
            let sep = "/"
            if (Scope.OS.Constants.Win) {
              console.log("win");
              sep = "\\"
            } else {
              console.log("unix");
              sep = "/"
            }

            let folderpath = filename + sep + "ERS_Extension" + sep + "logs"
            if (!await IOUtils.exists(folderpath)) {
              await IOUtils.makeDirectory(folderpath);
            }
            let file = folderpath + sep + "event" + new Date().getTime() + ".json";
            return await IOUtils.writeJSON(file, text);
          },
        },

      };
    }

    onShutdown(isAppShutdown) {
      // This function is called if the extension is disabled or removed, or Thunderbird closes.
      // We usually do not have to do any cleanup, if Thunderbird is shutting down entirely
      if (isAppShutdown) {
        return;
      }

      // Unload the JSM we imported above. This will cause Thunderbird to forget about the JSM, and
      // load it afresh next time `import` is called. (If you don't call `unload`, Thunderbird will
      // remember this version of the module and continue to use it, even if your extension receives
      // an update.) You should *always* unload JSMs provided by your extension.
      // Cu.unload(extension.rootURI.resolve("modules/myModule.jsm"));

      // Thunderbird might still cache some of your JavaScript files and even if JSMs have been unloaded,
      // the last used version could be reused on next load, ignoring any changes. Get around this issue
      // by invalidating the caches (this is identical to restarting TB with the -purgecaches parameter):
      Services.obs.notifyObservers(null, "startupcache-invalidate", null);
    }
  };

  // Export the api by assigning in to the exports parameter of the anonymous closure
  // function, which is the global this.
  exports.myapi = myapi;

})(this)
